import { BcsReader } from './reader';
import { BcsWriter, BcsWriterOptions } from './writer';
export interface BcsTypeOptions<T, Input = T> {
    name?: string;
    validate?: (value: Input) => void;
}
export declare class BcsType<T, Input = T> {
    #private;
    $inferType: T;
    $inferInput: Input;
    name: string;
    read: (reader: BcsReader) => T;
    serializedSize: (value: Input, options?: BcsWriterOptions) => number | null;
    validate: (value: Input) => void;
    constructor(options: {
        name: string;
        read: (reader: BcsReader) => T;
        write: (value: Input, writer: BcsWriter) => void;
        serialize?: (value: Input, options?: BcsWriterOptions) => Uint8Array;
        serializedSize?: (value: Input) => number | null;
        validate?: (value: Input) => void;
    } & BcsTypeOptions<T, Input>);
    write(value: Input, writer: BcsWriter): void;
    serialize(value: Input, options?: BcsWriterOptions): SerializedBcs<T, Input>;
    parse(bytes: Uint8Array): T;
    transform<T2, Input2>({ name, input, output, }: {
        input: (val: Input2) => Input;
        output: (value: T) => T2;
    } & BcsTypeOptions<T2, Input2>): BcsType<T2, Input2>;
}
declare const SERIALIZED_BCS_BRAND: unique symbol;
export declare function isSerializedBcs(obj: unknown): obj is SerializedBcs<unknown>;
export declare class SerializedBcs<T, Input = T> {
    #private;
    get [SERIALIZED_BCS_BRAND](): boolean;
    constructor(type: BcsType<T, Input>, schema: Uint8Array);
    toBytes(): Uint8Array;
    toHex(): string;
    toBase64(): string;
    toBase58(): string;
    parse(): T;
}
export declare function fixedSizeBcsType<T, Input = T>({ size, ...options }: {
    name: string;
    size: number;
    read: (reader: BcsReader) => T;
    write: (value: Input, writer: BcsWriter) => void;
} & BcsTypeOptions<T, Input>): BcsType<T, Input>;
export declare function uIntBcsType({ readMethod, writeMethod, ...options }: {
    name: string;
    size: number;
    readMethod: `read${8 | 16 | 32}`;
    writeMethod: `write${8 | 16 | 32}`;
    maxValue: number;
} & BcsTypeOptions<number, number>): BcsType<number, number>;
export declare function bigUIntBcsType({ readMethod, writeMethod, ...options }: {
    name: string;
    size: number;
    readMethod: `read${64 | 128 | 256}`;
    writeMethod: `write${64 | 128 | 256}`;
    maxValue: bigint;
} & BcsTypeOptions<string, string | number | bigint>): BcsType<string, string | number | bigint>;
export declare function dynamicSizeBcsType<T, Input = T>({ serialize, ...options }: {
    name: string;
    read: (reader: BcsReader) => T;
    serialize: (value: Input, options?: BcsWriterOptions) => Uint8Array;
} & BcsTypeOptions<T, Input>): BcsType<T, Input>;
export declare function stringLikeBcsType({ toBytes, fromBytes, ...options }: {
    name: string;
    toBytes: (value: string) => Uint8Array;
    fromBytes: (bytes: Uint8Array) => string;
    serializedSize?: (value: string) => number | null;
} & BcsTypeOptions<string>): BcsType<string, string>;
export declare function lazyBcsType<T, Input>(cb: () => BcsType<T, Input>): BcsType<T, Input>;
export {};
