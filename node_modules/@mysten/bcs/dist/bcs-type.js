// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BcsType_write, _BcsType_serialize, _SerializedBcs_schema, _SerializedBcs_bytes;
import { toB58 } from './b58';
import { toB64 } from './b64';
import { toHEX } from './hex';
import { BcsReader } from './reader';
import { ulebEncode } from './uleb';
import { BcsWriter } from './writer';
export class BcsType {
    constructor(options) {
        _BcsType_write.set(this, void 0);
        _BcsType_serialize.set(this, void 0);
        this.name = options.name;
        this.read = options.read;
        this.serializedSize = options.serializedSize ?? (() => null);
        __classPrivateFieldSet(this, _BcsType_write, options.write, "f");
        __classPrivateFieldSet(this, _BcsType_serialize, options.serialize ??
            ((value, options) => {
                const writer = new BcsWriter({ size: this.serializedSize(value) ?? undefined, ...options });
                __classPrivateFieldGet(this, _BcsType_write, "f").call(this, value, writer);
                return writer.toBytes();
            }), "f");
        this.validate = options.validate ?? (() => { });
    }
    write(value, writer) {
        this.validate(value);
        __classPrivateFieldGet(this, _BcsType_write, "f").call(this, value, writer);
    }
    serialize(value, options) {
        this.validate(value);
        return new SerializedBcs(this, __classPrivateFieldGet(this, _BcsType_serialize, "f").call(this, value, options));
    }
    parse(bytes) {
        const reader = new BcsReader(bytes);
        return this.read(reader);
    }
    transform({ name, input, output, }) {
        return new BcsType({
            name: name ?? this.name,
            read: (reader) => output(this.read(reader)),
            write: (value, writer) => __classPrivateFieldGet(this, _BcsType_write, "f").call(this, input(value), writer),
            serializedSize: (value) => this.serializedSize(input(value)),
            serialize: (value, options) => __classPrivateFieldGet(this, _BcsType_serialize, "f").call(this, input(value), options),
            validate: (value) => this.validate(input(value)),
        });
    }
}
_BcsType_write = new WeakMap(), _BcsType_serialize = new WeakMap();
const SERIALIZED_BCS_BRAND = Symbol.for('@mysten/serialized-bcs');
export function isSerializedBcs(obj) {
    return !!obj && typeof obj === 'object' && obj[SERIALIZED_BCS_BRAND] === true;
}
export class SerializedBcs {
    // Used to brand SerializedBcs so that they can be identified, even between multiple copies
    // of the @mysten/bcs package are installed
    get [(_SerializedBcs_schema = new WeakMap(), _SerializedBcs_bytes = new WeakMap(), SERIALIZED_BCS_BRAND)]() {
        return true;
    }
    constructor(type, schema) {
        _SerializedBcs_schema.set(this, void 0);
        _SerializedBcs_bytes.set(this, void 0);
        __classPrivateFieldSet(this, _SerializedBcs_schema, type, "f");
        __classPrivateFieldSet(this, _SerializedBcs_bytes, schema, "f");
    }
    toBytes() {
        return __classPrivateFieldGet(this, _SerializedBcs_bytes, "f");
    }
    toHex() {
        return toHEX(__classPrivateFieldGet(this, _SerializedBcs_bytes, "f"));
    }
    toBase64() {
        return toB64(__classPrivateFieldGet(this, _SerializedBcs_bytes, "f"));
    }
    toBase58() {
        return toB58(__classPrivateFieldGet(this, _SerializedBcs_bytes, "f"));
    }
    parse() {
        return __classPrivateFieldGet(this, _SerializedBcs_schema, "f").parse(__classPrivateFieldGet(this, _SerializedBcs_bytes, "f"));
    }
}
export function fixedSizeBcsType({ size, ...options }) {
    return new BcsType({
        ...options,
        serializedSize: () => size,
    });
}
export function uIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader) => reader[readMethod](),
        write: (value, writer) => writer[writeMethod](value),
        validate: (value) => {
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        },
    });
}
export function bigUIntBcsType({ readMethod, writeMethod, ...options }) {
    return fixedSizeBcsType({
        ...options,
        read: (reader) => reader[readMethod](),
        write: (value, writer) => writer[writeMethod](BigInt(value)),
        validate: (val) => {
            const value = BigInt(val);
            if (value < 0 || value > options.maxValue) {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);
            }
            options.validate?.(value);
        },
    });
}
export function dynamicSizeBcsType({ serialize, ...options }) {
    const type = new BcsType({
        ...options,
        serialize,
        write: (value, writer) => {
            for (const byte of type.serialize(value).toBytes()) {
                writer.write8(byte);
            }
        },
    });
    return type;
}
export function stringLikeBcsType({ toBytes, fromBytes, ...options }) {
    return new BcsType({
        ...options,
        read: (reader) => {
            const length = reader.readULEB();
            const bytes = reader.readBytes(length);
            return fromBytes(bytes);
        },
        write: (hex, writer) => {
            const bytes = toBytes(hex);
            writer.writeULEB(bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                writer.write8(bytes[i]);
            }
        },
        serialize: (value) => {
            const bytes = toBytes(value);
            const size = ulebEncode(bytes.length);
            const result = new Uint8Array(size.length + bytes.length);
            result.set(size, 0);
            result.set(bytes, size.length);
            return result;
        },
        validate: (value) => {
            if (typeof value !== 'string') {
                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);
            }
            options.validate?.(value);
        },
    });
}
export function lazyBcsType(cb) {
    let lazyType = null;
    function getType() {
        if (!lazyType) {
            lazyType = cb();
        }
        return lazyType;
    }
    return new BcsType({
        name: 'lazy',
        read: (data) => getType().read(data),
        serializedSize: (value) => getType().serializedSize(value),
        write: (value, writer) => getType().write(value, writer),
        serialize: (value, options) => getType().serialize(value, options).toBytes(),
    });
}
