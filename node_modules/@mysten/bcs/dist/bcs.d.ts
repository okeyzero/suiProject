import { BcsType, BcsTypeOptions } from './bcs-type.js';
import { GenericPlaceholder, ReplaceBcsGenerics } from './types.js';
export declare const bcs: {
    /**
     * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.
     * @example
     * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]
     */
    u8(options?: BcsTypeOptions<number>): BcsType<number, number>;
    /**
     * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.
     * @example
     * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]
     */
    u16(options?: BcsTypeOptions<number>): BcsType<number, number>;
    /**
     * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.
     * @example
     * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]
     */
    u32(options?: BcsTypeOptions<number>): BcsType<number, number>;
    /**
     * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.
     * @example
     * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]
     */
    u64(options?: BcsTypeOptions<string, number | bigint | string>): BcsType<string, string | number | bigint>;
    /**
     * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.
     * @example
     * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
     */
    u128(options?: BcsTypeOptions<string, number | bigint | string>): BcsType<string, string | number | bigint>;
    /**
     * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.
     * @example
     * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]
     */
    u256(options?: BcsTypeOptions<string, number | bigint | string>): BcsType<string, string | number | bigint>;
    /**
     * Creates a BcsType that can be used to read and write boolean values.
     * @example
     * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]
     */
    bool(options?: BcsTypeOptions<boolean>): BcsType<boolean, boolean>;
    /**
     * Creates a BcsType that can be used to read and write unsigned LEB encoded integers
     * @example
     *
     */
    uleb128(options?: BcsTypeOptions<number>): BcsType<number, number>;
    /**
     * Creates a BcsType representing a fixed length byte array
     * @param size The number of bytes this types represents
     * @example
     * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]
     */
    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>>): BcsType<Uint8Array, Uint8Array>;
    /**
     * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded
     * @example
     * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]
     */
    string(options?: BcsTypeOptions<string>): BcsType<string, string>;
    /**
     * Creates a BcsType that represents a fixed length array of a given type
     * @param size The number of elements in the array
     * @param type The BcsType of each element in the array
     * @example
     * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]
     */
    fixedArray<T_1, Input>(size: number, type: BcsType<T_1, Input>, options?: BcsTypeOptions<T_1[], Iterable<Input> & {
        length: number;
    }> | undefined): BcsType<T_1[], Iterable<Input> & {
        length: number;
    }>;
    /**
     * Creates a BcsType representing an optional value
     * @param type The BcsType of the optional value
     * @example
     * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]
     * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]
     */
    option<T_2, Input_1>(type: BcsType<T_2, Input_1>): BcsType<T_2 | null, Input_1 | null | undefined>;
    /**
     * Creates a BcsType representing a variable length vector of a given type
     * @param type The BcsType of each element in the vector
     *
     * @example
     * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]
     */
    vector<T_3, Input_2>(type: BcsType<T_3, Input_2>, options?: BcsTypeOptions<T_3[], Iterable<Input_2> & {
        length: number;
    }> | undefined): BcsType<T_3[], Iterable<Input_2> & {
        length: number;
    }>;
    /**
     * Creates a BcsType representing a tuple of a given set of types
     * @param types The BcsTypes for each element in the tuple
     *
     * @example
     * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])
     * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]
     */
    tuple<const Types extends readonly BcsType<any, any>[]>(types: Types, options?: BcsTypeOptions<{ -readonly [K in keyof Types]: Types[K] extends BcsType<infer T_4, any> ? T_4 : never; }, { [K_1 in keyof Types]: Types[K_1] extends BcsType<any, infer T_5> ? T_5 : never; }> | undefined): BcsType<{ -readonly [K_2 in keyof Types]: Types[K_2] extends BcsType<infer T_6, any> ? T_6 : never; }, { [K_3 in keyof Types]: Types[K_3] extends BcsType<any, infer T_7> ? T_7 : never; }>;
    /**
     * Creates a BcsType representing a struct of a given set of fields
     * @param name The name of the struct
     * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized
     *
     * @example
     * const struct = bcs.struct('MyStruct', {
     *  a: bcs.u8(),
     *  b: bcs.string(),
     * })
     * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
     */
    struct<T_8 extends Record<string, BcsType<any, any>>>(name: string, fields: T_8, options?: Omit<BcsTypeOptions<{ [K_4 in keyof T_8]: T_8[K_4] extends BcsType<infer U, any> ? U : never; }, { [K_5 in keyof T_8]: T_8[K_5] extends BcsType<any, infer U_1> ? U_1 : never; }>, "name"> | undefined): BcsType<{ [K_6 in keyof T_8]: T_8[K_6] extends BcsType<infer U_2, any> ? U_2 : never; }, { [K_7 in keyof T_8]: T_8[K_7] extends BcsType<any, infer U_3> ? U_3 : never; }>;
    /**
     * Creates a BcsType representing an enum of a given set of options
     * @param name The name of the enum
     * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.
     * null can be used to represent a variant with no data.
     *
     * @example
     * const enum = bcs.enum('MyEnum', {
     *   A: bcs.u8(),
     *   B: bcs.string(),
     *   C: null,
     * })
     * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]
     * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]
     * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]
     */
    enum<T_9 extends Record<string, BcsType<any, any> | null>>(name: string, values: T_9, options?: Omit<BcsTypeOptions<{ [K_8 in keyof T_9]: T_9[K_8] extends BcsType<infer U_4, any> ? { [K2 in K_8]: U_4; } : { [K2_1 in K_8]: true; }; }[keyof T_9], { [K_9 in keyof T_9]: T_9[K_9] extends BcsType<any, infer U_5> ? { [K2_2 in K_9]: U_5; } : { [K2_3 in K_9]: unknown; }; }[keyof T_9]>, "name"> | undefined): BcsType<{ [K_10 in keyof T_9]: T_9[K_10] extends BcsType<infer U_6, any> ? { [K2_4 in K_10]: U_6; } : { [K2_5 in K_10]: true; }; }[keyof T_9], { [K_11 in keyof T_9]: T_9[K_11] extends BcsType<any, infer U_7> ? { [K2_6 in K_11]: U_7; } : { [K2_7 in K_11]: unknown; }; }[keyof T_9]>;
    /**
     * Creates a BcsType representing a map of a given key and value type
     * @param keyType The BcsType of the key
     * @param valueType The BcsType of the value
     * @example
     * const map = bcs.map(bcs.u8(), bcs.string())
     * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]
     */
    map<K_12, V, InputK = K_12, InputV = V>(keyType: BcsType<K_12, InputK>, valueType: BcsType<V, InputV>): BcsType<Map<K_12, V>, Map<InputK, InputV>>;
    /**
     * @deprecated
     *
     * Generics should be implemented as generic typescript functions instead:
     *
     * ```ts
     * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {
     *   return bcs.struct('VecMap<K, V>', {
     *     keys: bcs.vector(K),
     *     values: bcs.vector(V),
     *   })
     * }
     * ```
     */
    generic<const Names extends readonly string[], const Type extends BcsType<any, any>>(names: Names, cb: (...types: { [K_13 in keyof Names]: BcsType<GenericPlaceholder<Names[K_13]>, GenericPlaceholder<Names[K_13]>>; }) => Type): <T_10 extends { [K_14 in keyof Names]: BcsType<any, any>; }>(...types: T_10) => ReplaceBcsGenerics<Type, Names, T_10>;
    /**
     * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.
     * @param cb A callback that returns the BcsType
     */
    lazy<T_11 extends BcsType<any, any>>(cb: () => T_11): T_11;
};
