import { BcsType } from './bcs-type.js';
import { BcsReader } from './reader.js';
import { Encoding } from './types.js';
import { BcsWriter, BcsWriterOptions } from './writer.js';
/**
 * Allows for array definitions for names.
 * @example
 * ```
 * bcs.registerStructType(['vector', BCS.STRING], ...);
 * // equals
 * bcs.registerStructType('vector<string>', ...);
 * ```
 */
export type TypeName = string | [string, ...(TypeName | string)[]];
export interface TypeInterface {
    encode: (self: BCS, data: any, options: BcsWriterOptions | undefined, typeParams: TypeName[]) => BcsWriter;
    decode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;
    _encodeRaw: (writer: BcsWriter, data: any, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => BcsWriter;
    _decodeRaw: (reader: BcsReader, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => any;
}
/**
 * Struct type definition. Used as input format in BcsConfig.types
 * as well as an argument type for `bcs.registerStructType`.
 */
export type StructTypeDefinition = {
    [key: string]: TypeName | StructTypeDefinition;
};
/**
 * Enum type definition. Used as input format in BcsConfig.types
 * as well as an argument type for `bcs.registerEnumType`.
 *
 * Value can be either `string` when invariant has a type or `null`
 * when invariant is empty.
 *
 * @example
 * bcs.registerEnumType('Option<T>', {
 *   some: 'T',
 *   none: null
 * });
 */
export type EnumTypeDefinition = {
    [key: string]: TypeName | StructTypeDefinition | null;
};
/**
 * Configuration that is passed into BCS constructor.
 */
export type BcsConfig = {
    /**
     * Defines type name for the vector / array type.
     * In Move: `vector<T>` or `vector`.
     */
    vectorType: string;
    /**
     * Address length. Varies depending on a platform and
     * has to be specified for the `address` type.
     */
    addressLength: number;
    /**
     * Custom encoding for address. Supported values are
     * either 'hex' or 'base64'.
     */
    addressEncoding?: 'hex' | 'base64';
    /**
     * Opening and closing symbol for type parameters. Can be
     * any pair of symbols (eg `['(', ')']`); default value follows
     * Rust and Move: `<` and `>`.
     */
    genericSeparators?: [string, string];
    /**
     * Type definitions for the BCS. This field allows spawning
     * BCS instance from JSON or another prepared configuration.
     * Optional.
     */
    types?: {
        structs?: {
            [key: string]: StructTypeDefinition;
        };
        enums?: {
            [key: string]: EnumTypeDefinition;
        };
        aliases?: {
            [key: string]: string;
        };
    };
    /**
     * Whether to auto-register primitive types on launch.
     */
    withPrimitives?: boolean;
};
/**
 * BCS implementation for Move types and few additional built-ins.
 */
export declare class BCS {
    static readonly U8 = "u8";
    static readonly U16 = "u16";
    static readonly U32 = "u32";
    static readonly U64 = "u64";
    static readonly U128 = "u128";
    static readonly U256 = "u256";
    static readonly BOOL = "bool";
    static readonly VECTOR = "vector";
    static readonly ADDRESS = "address";
    static readonly STRING = "string";
    static readonly HEX = "hex-string";
    static readonly BASE58 = "base58-string";
    static readonly BASE64 = "base64-string";
    /**
     * Map of kind `TypeName => TypeInterface`. Holds all
     * callbacks for (de)serialization of every registered type.
     *
     * If the value stored is a string, it is treated as an alias.
     */
    types: Map<string, TypeInterface | string>;
    /**
     * Stored BcsConfig for the current instance of BCS.
     */
    protected schema: BcsConfig;
    /**
     * Count temp keys to generate a new one when requested.
     */
    protected counter: number;
    /**
     * Name of the key to use for temporary struct definitions.
     * Returns a temp key + index (for a case when multiple temp
     * structs are processed).
     */
    private tempKey;
    /**
     * Construct a BCS instance with a prepared schema.
     *
     * @param schema A prepared schema with type definitions
     * @param withPrimitives Whether to register primitive types by default
     */
    constructor(schema: BcsConfig | BCS);
    /**
     * Serialize data into bcs.
     *
     * @example
     * bcs.registerVectorType('vector<u8>', 'u8');
     *
     * let serialized = BCS
     *   .set('vector<u8>', [1,2,3,4,5,6])
     *   .toBytes();
     *
     * console.assert(toHex(serialized) === '06010203040506');
     *
     * @param type Name of the type to serialize (must be registered) or a struct type.
     * @param data Data to serialize.
     * @param size Serialization buffer size. Default 1024 = 1KB.
     * @return A BCS reader instance. Usually you'd want to call `.toBytes()`
     */
    ser(type: TypeName | StructTypeDefinition, data: any, options?: BcsWriterOptions): BcsWriter;
    /**
     * Deserialize BCS into a JS type.
     *
     * @example
     * let num = bcs.ser('u64', '4294967295').toString('hex');
     * let deNum = bcs.de('u64', num, 'hex');
     * console.assert(deNum.toString(10) === '4294967295');
     *
     * @param type Name of the type to deserialize (must be registered) or a struct type definition.
     * @param data Data to deserialize.
     * @param encoding Optional - encoding to use if data is of type String
     * @return Deserialized data.
     */
    de(type: TypeName | StructTypeDefinition, data: Uint8Array | string, encoding?: Encoding): any;
    /**
     * Check whether a `TypeInterface` has been loaded for a `type`.
     * @param type Name of the type to check.
     * @returns
     */
    hasType(type: string): boolean;
    /**
     * Create an alias for a type.
     * WARNING: this can potentially lead to recursion
     * @param name Alias to use
     * @param forType Type to reference
     * @returns
     *
     * @example
     * ```
     * let bcs = new BCS(getSuiMoveConfig());
     * bcs.registerAlias('ObjectDigest', BCS.BASE58);
     * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');
     * ```
     */
    registerAlias(name: string, forType: string): BCS;
    /**
     * Method to register new types for BCS internal representation.
     * For each registered type 2 callbacks must be specified and one is optional:
     *
     * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;
     * - decodeCb(reader) - write a way to deserialize data with BcsReader;
     * - validateCb(data) - validate data - either return bool or throw an error
     *
     * @example
     * // our type would be a string that consists only of numbers
     * bcs.registerType('number_string',
     *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),
     *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8
     *    (value) => /[0-9]+/.test(value) // test that it has at least one digit
     * );
     * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);
     *
     * @param name
     * @param encodeCb Callback to encode a value.
     * @param decodeCb Callback to decode a value.
     * @param validateCb Optional validator Callback to check type before serialization.
     */
    registerType(typeName: TypeName, encodeCb: (writer: BcsWriter, data: any, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => BcsWriter, decodeCb: (reader: BcsReader, typeParams: TypeName[], typeMap: {
        [key: string]: TypeName;
    }) => any, validateCb?: (data: any) => boolean): BCS;
    /**
     * Method to register BcsType instances to the registry
     * Types are registered with a callback that provides BcsType instances for each generic
     * passed to the type.
     *
     * - createType(...generics) - Return a BcsType instance
     *
     * @example
     * // our type would be a string that consists only of numbers
     * bcs.registerType('Box<T>', (T) => {
     * 		return bcs.struct({
     * 			value: T
     * 		});
     * });

     * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);
     *
     * @param name
     * @param createType a Callback to create the BcsType with any passed in generics
     */
    registerBcsType(typeName: TypeName, createType: (...params: BcsType<any>[]) => BcsType<any>): this;
    /**
     * Register an address type which is a sequence of U8s of specified length.
     * @example
     * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);
     * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');
     *
     * @param name Name of the address type.
     * @param length Byte length of the address.
     * @param encoding Encoding to use for the address type
     * @returns
     */
    registerAddressType(name: string, length: number, encoding?: Encoding | void): BCS;
    /**
     * Register custom vector type inside the bcs.
     *
     * @example
     * bcs.registerVectorType('vector<T>'); // generic registration
     * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];
     * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');
     *
     * @param name Name of the type to register
     * @param elementType Optional name of the inner type of the vector
     * @return Returns self for chaining.
     */
    private registerVectorType;
    /**
     * Safe method to register a custom Move struct. The first argument is a name of the
     * struct which is only used on the FrontEnd and has no affect on serialization results,
     * and the second is a struct description passed as an Object.
     *
     * The description object MUST have the same order on all of the platforms (ie in Move
     * or in Rust).
     *
     * @example
     * // Move / Rust struct
     * // struct Coin {
     * //   value: u64,
     * //   owner: vector<u8>, // name // Vec<u8> in Rust
     * //   is_locked: bool,
     * // }
     *
     * bcs.registerStructType('Coin', {
     *   value: bcs.U64,
     *   owner: bcs.STRING,
     *   is_locked: bcs.BOOL
     * });
     *
     * // Created in Rust with diem/bcs
     * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';
     * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array
     *  128, 209, 177,   5,  96,  0,  0,
     *    0,  14,  66, 105, 103, 32, 87,
     *   97, 108, 108, 101, 116, 32, 71,
     *  117, 121,   0
     * ];
     *
     * // Let's encode the value as well
     * let test_set = bcs.ser('Coin', {
     *   owner: 'Big Wallet Guy',
     *   value: '412412400000',
     *   is_locked: false,
     * });
     *
     * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');
     *
     * @param name Name of the type to register.
     * @param fields Fields of the struct. Must be in the correct order.
     * @return Returns BCS for chaining.
     */
    registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS;
    /**
     * Safe method to register custom enum type where each invariant holds the value of another type.
     * @example
     * bcs.registerStructType('Coin', { value: 'u64' });
     * bcs.registerEnumType('MyEnum', {
     *  single: 'Coin',
     *  multi: 'vector<Coin>',
     *  empty: null
     * });
     *
     * console.log(
     *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }
     *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }
     * )
     *
     * // and serialization
     * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();
     * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });
     *
     * @param name
     * @param variants
     */
    registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS;
    /**
     * Get a set of encoders/decoders for specific type.
     * Mainly used to define custom type de/serialization logic.
     *
     * @param type
     * @returns {TypeInterface}
     */
    getTypeInterface(type: string): TypeInterface;
    /**
     * Parse a type name and get the type's generics.
     * @example
     * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');
     * // typeName: Option
     * // typeParams: [ 'Coin<SUI>' ]
     *
     * @param name Name of the type to process
     * @returns Object with typeName and typeParams listed as Array
     */
    parseTypeName(name: TypeName): {
        name: string;
        params: TypeName[];
    };
}
/**
 * Register the base set of primitive and common types.
 * Is called in the `BCS` constructor automatically but can
 * be ignored if the `withPrimitives` argument is not set.
 */
export declare function registerPrimitives(bcs: BCS): void;
export declare function getRustConfig(): BcsConfig;
export declare function getSuiMoveConfig(): BcsConfig;
