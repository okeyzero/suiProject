"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var bcs_exports = {};
__export(bcs_exports, {
  TypeTagSerializer: () => import_type_tag_serializer2.TypeTagSerializer,
  bcs: () => suiBcs,
  bcsRegistry: () => bcsRegistry,
  isPureArg: () => isPureArg
});
module.exports = __toCommonJS(bcs_exports);
var import_bcs = require("@mysten/bcs");
var import_sui_types = require("../utils/sui-types.js");
var import_type_tag_serializer = require("./type-tag-serializer.js");
var import_type_tag_serializer2 = require("./type-tag-serializer.js");
function isPureArg(arg) {
  return arg.Pure !== void 0;
}
const bcsRegistry = new import_bcs.BCS({
  ...(0, import_bcs.getSuiMoveConfig)(),
  types: {
    enums: {
      "Option<T>": {
        None: null,
        Some: "T"
      }
    }
  }
});
function unsafe_u64(options) {
  return import_bcs.bcs.u64({
    name: "unsafe_u64",
    ...options
  }).transform({
    input: (val) => val,
    output: (val) => Number(val)
  });
}
function optionEnum(type) {
  return import_bcs.bcs.enum("Option", {
    None: null,
    Some: type
  });
}
function enumKind(type) {
  return type.transform({
    input: (val) => ({
      [val.kind]: val
    }),
    output: (val) => {
      const key = Object.keys(val)[0];
      return { kind: key, ...val[key] };
    }
  });
}
const Address = import_bcs.bcs.bytes(import_sui_types.SUI_ADDRESS_LENGTH).transform({
  input: (val) => typeof val === "string" ? (0, import_bcs.fromHEX)((0, import_sui_types.normalizeSuiAddress)(val)) : val,
  output: (val) => (0, import_sui_types.normalizeSuiAddress)((0, import_bcs.toHEX)(val))
});
const ObjectDigest = import_bcs.bcs.vector(import_bcs.bcs.u8()).transform({
  name: "ObjectDigest",
  input: (value) => (0, import_bcs.fromB58)(value),
  output: (value) => (0, import_bcs.toB58)(new Uint8Array(value))
});
const SuiObjectRef = import_bcs.bcs.struct("SuiObjectRef", {
  objectId: Address,
  version: import_bcs.bcs.u64(),
  digest: ObjectDigest
});
const SharedObjectRef = import_bcs.bcs.struct("SharedObjectRef", {
  objectId: Address,
  initialSharedVersion: import_bcs.bcs.u64(),
  mutable: import_bcs.bcs.bool()
});
const ObjectArg = import_bcs.bcs.enum("ObjectArg", {
  ImmOrOwned: SuiObjectRef,
  Shared: SharedObjectRef,
  Receiving: SuiObjectRef
});
const CallArg = import_bcs.bcs.enum("CallArg", {
  Pure: import_bcs.bcs.vector(import_bcs.bcs.u8()),
  Object: ObjectArg,
  ObjVec: import_bcs.bcs.vector(ObjectArg)
});
const TypeTag = import_bcs.bcs.enum("TypeTag", {
  bool: null,
  u8: null,
  u64: null,
  u128: null,
  address: null,
  signer: null,
  vector: import_bcs.bcs.lazy(() => TypeTag),
  struct: import_bcs.bcs.lazy(() => StructTag),
  u16: null,
  u32: null,
  u256: null
});
const Argument = enumKind(
  import_bcs.bcs.enum("Argument", {
    GasCoin: null,
    Input: import_bcs.bcs.struct("Input", { index: import_bcs.bcs.u16() }),
    Result: import_bcs.bcs.struct("Result", { index: import_bcs.bcs.u16() }),
    NestedResult: import_bcs.bcs.struct("NestedResult", { index: import_bcs.bcs.u16(), resultIndex: import_bcs.bcs.u16() })
  })
);
const ProgrammableMoveCall = import_bcs.bcs.struct("ProgrammableMoveCall", {
  package: Address,
  module: import_bcs.bcs.string(),
  function: import_bcs.bcs.string(),
  type_arguments: import_bcs.bcs.vector(TypeTag),
  arguments: import_bcs.bcs.vector(Argument)
}).transform({
  input: (data) => {
    const [pkg, module2, fun] = data.target.split("::");
    const type_arguments = data.typeArguments.map(
      (tag) => import_type_tag_serializer.TypeTagSerializer.parseFromStr(tag, true)
    );
    return {
      package: (0, import_sui_types.normalizeSuiAddress)(pkg),
      module: module2,
      function: fun,
      type_arguments,
      arguments: data.arguments
    };
  },
  output: (data) => {
    return {
      target: [data.package, data.module, data.function].join(
        "::"
      ),
      arguments: data.arguments,
      typeArguments: data.type_arguments.map(import_type_tag_serializer.TypeTagSerializer.tagToString)
    };
  }
});
const Transaction = enumKind(
  import_bcs.bcs.enum("Transaction", {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: ProgrammableMoveCall,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: import_bcs.bcs.struct("TransferObjects", {
      objects: import_bcs.bcs.vector(Argument),
      address: Argument
    }),
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: import_bcs.bcs.struct("SplitCoins", { coin: Argument, amounts: import_bcs.bcs.vector(Argument) }),
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: import_bcs.bcs.struct("MergeCoins", { destination: Argument, sources: import_bcs.bcs.vector(Argument) }),
    /**
     * Publish a Move module.
     */
    Publish: import_bcs.bcs.struct("Publish", {
      modules: import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())),
      dependencies: import_bcs.bcs.vector(Address)
    }),
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: import_bcs.bcs.struct("MakeMoveVec", {
      type: optionEnum(TypeTag),
      objects: import_bcs.bcs.vector(Argument)
    }),
    /**  */
    Upgrade: import_bcs.bcs.struct("Upgrade", {
      modules: import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8())),
      dependencies: import_bcs.bcs.vector(Address),
      packageId: Address,
      ticket: Argument
    })
  })
);
const ProgrammableTransaction = import_bcs.bcs.struct("ProgrammableTransaction", {
  inputs: import_bcs.bcs.vector(CallArg),
  transactions: import_bcs.bcs.vector(Transaction)
});
const TransactionKind = import_bcs.bcs.enum("TransactionKind", {
  ProgrammableTransaction,
  ChangeEpoch: null,
  Genesis: null,
  ConsensusCommitPrologue: null
});
const TransactionExpiration = import_bcs.bcs.enum("TransactionExpiration", {
  None: null,
  Epoch: unsafe_u64()
});
const StructTag = import_bcs.bcs.struct("StructTag", {
  address: Address,
  module: import_bcs.bcs.string(),
  name: import_bcs.bcs.string(),
  typeParams: import_bcs.bcs.vector(TypeTag)
});
const GasData = import_bcs.bcs.struct("GasData", {
  payment: import_bcs.bcs.vector(SuiObjectRef),
  owner: Address,
  price: import_bcs.bcs.u64(),
  budget: import_bcs.bcs.u64()
});
const TransactionDataV1 = import_bcs.bcs.struct("TransactionDataV1", {
  kind: TransactionKind,
  sender: Address,
  gasData: GasData,
  expiration: TransactionExpiration
});
const TransactionData = import_bcs.bcs.enum("TransactionData", {
  V1: TransactionDataV1
});
const SenderSignedData = import_bcs.bcs.struct("SenderSignedData", {
  data: TransactionData,
  txSignatures: import_bcs.bcs.vector(import_bcs.bcs.vector(import_bcs.bcs.u8()))
});
const CompressedSignature = import_bcs.bcs.enum("CompressedSignature", {
  ED25519: import_bcs.bcs.fixedArray(64, import_bcs.bcs.u8()),
  Secp256k1: import_bcs.bcs.fixedArray(64, import_bcs.bcs.u8()),
  Secp256r1: import_bcs.bcs.fixedArray(64, import_bcs.bcs.u8()),
  ZkLogin: import_bcs.bcs.vector(import_bcs.bcs.u8())
});
const PublicKey = import_bcs.bcs.enum("PublicKey", {
  ED25519: import_bcs.bcs.fixedArray(32, import_bcs.bcs.u8()),
  Secp256k1: import_bcs.bcs.fixedArray(33, import_bcs.bcs.u8()),
  Secp256r1: import_bcs.bcs.fixedArray(33, import_bcs.bcs.u8()),
  ZkLogin: import_bcs.bcs.vector(import_bcs.bcs.u8())
});
const MultiSigPkMap = import_bcs.bcs.struct("MultiSigPkMap", {
  pubKey: PublicKey,
  weight: import_bcs.bcs.u8()
});
const MultiSigPublicKey = import_bcs.bcs.struct("MultiSigPublicKey", {
  pk_map: import_bcs.bcs.vector(MultiSigPkMap),
  threshold: import_bcs.bcs.u16()
});
const MultiSig = import_bcs.bcs.struct("MultiSig", {
  sigs: import_bcs.bcs.vector(CompressedSignature),
  bitmap: import_bcs.bcs.u16(),
  multisig_pk: MultiSigPublicKey
});
const suiBcs = {
  ...import_bcs.bcs,
  U8: import_bcs.bcs.u8(),
  U16: import_bcs.bcs.u16(),
  U32: import_bcs.bcs.u32(),
  U64: import_bcs.bcs.u64(),
  U128: import_bcs.bcs.u128(),
  U256: import_bcs.bcs.u256(),
  ULEB128: import_bcs.bcs.uleb128(),
  Bool: import_bcs.bcs.bool(),
  String: import_bcs.bcs.string(),
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag,
  // preserve backwards compatibility with old bcs export
  ser: bcsRegistry.ser.bind(bcsRegistry),
  de: bcsRegistry.de.bind(bcsRegistry),
  getTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),
  hasType: bcsRegistry.hasType.bind(bcsRegistry),
  parseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),
  registerAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),
  registerAlias: bcsRegistry.registerAlias.bind(bcsRegistry),
  registerBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),
  registerEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),
  registerStructType: bcsRegistry.registerStructType.bind(bcsRegistry),
  registerType: bcsRegistry.registerType.bind(bcsRegistry),
  types: bcsRegistry.types
};
bcsRegistry.registerBcsType("utf8string", () => import_bcs.bcs.string({ name: "utf8string" }));
bcsRegistry.registerBcsType("unsafe_u64", () => unsafe_u64());
bcsRegistry.registerBcsType("enumKind", (T) => enumKind(T));
[
  Address,
  Argument,
  CallArg,
  CompressedSignature,
  GasData,
  MultiSig,
  MultiSigPkMap,
  MultiSigPublicKey,
  ObjectArg,
  ObjectDigest,
  ProgrammableMoveCall,
  ProgrammableTransaction,
  PublicKey,
  SenderSignedData,
  SharedObjectRef,
  StructTag,
  SuiObjectRef,
  Transaction,
  TransactionData,
  TransactionDataV1,
  TransactionExpiration,
  TransactionKind,
  TypeTag
].forEach((type) => {
  bcsRegistry.registerBcsType(type.name, () => type);
});
//# sourceMappingURL=index.js.map
