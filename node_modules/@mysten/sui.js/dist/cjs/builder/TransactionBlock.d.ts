import type { SerializedBcs } from '@mysten/bcs';
import type { ProtocolConfig, SuiClient } from '../client/index.js';
import type { Keypair, SignatureWithBytes } from '../cryptography/index.js';
import { SuiObjectRef } from '../types/index.js';
import type { ObjectCallArg } from './Inputs.js';
import { Inputs } from './Inputs.js';
import { createPure } from './pure.js';
import type { TransactionExpiration } from './TransactionBlockData.js';
import type { TransactionArgument, TransactionType } from './Transactions.js';
export type TransactionObjectArgument = Exclude<TransactionArgument, {
    kind: 'Input';
    type: 'pure';
}>;
export type TransactionResult = Extract<TransactionArgument, {
    kind: 'Result';
}> & Extract<TransactionArgument, {
    kind: 'NestedResult';
}>[];
declare const TRANSACTION_BRAND: unique symbol;
declare const LIMITS: {
    readonly maxTxGas: "max_tx_gas";
    readonly maxGasObjects: "max_gas_payment_objects";
    readonly maxTxSizeBytes: "max_tx_size_bytes";
    readonly maxPureArgumentSize: "max_pure_argument_size";
};
type Limits = Partial<Record<keyof typeof LIMITS, number>>;
interface BuildOptions {
    client?: SuiClient;
    onlyTransactionKind?: boolean;
    /** Define a protocol config to build against, instead of having it fetched from the provider at build time. */
    protocolConfig?: ProtocolConfig;
    /** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */
    limits?: Limits;
}
interface SignOptions extends BuildOptions {
    signer: Keypair;
}
export declare function isTransactionBlock(obj: unknown): obj is TransactionBlock;
export type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;
/**
 * Transaction Builder
 */
export declare class TransactionBlock {
    #private;
    /**
     * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.
     * Supports either a byte array, or base64-encoded bytes.
     */
    static fromKind(serialized: string | Uint8Array): TransactionBlock;
    /**
     * Converts from a serialized transaction format to a `Transaction` class.
     * There are two supported serialized formats:
     * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.
     * - A byte array (or base64-encoded bytes) containing BCS transaction data.
     */
    static from(serialized: string | Uint8Array): TransactionBlock;
    setSender(sender: string): void;
    /**
     * Sets the sender only if it has not already been set.
     * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.
     */
    setSenderIfNotSet(sender: string): void;
    setExpiration(expiration?: TransactionExpiration): void;
    setGasPrice(price: number | bigint): void;
    setGasBudget(budget: number | bigint): void;
    setGasOwner(owner: string): void;
    setGasPayment(payments: SuiObjectRef[]): void;
    /** Get a snapshot of the transaction data, in JSON form: */
    get blockData(): {
        version: 1;
        inputs: ({
            index: number;
            kind: "Input";
            type?: "object" | undefined;
            value?: any;
        } | {
            type: "pure";
            index: number;
            kind: "Input";
            value?: any;
        })[];
        transactions: ({
            typeArguments: string[];
            kind: "MoveCall";
            arguments: ({
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            })[];
            target: `${string}::${string}::${string}`;
        } | {
            address: {
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            };
            kind: "TransferObjects";
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            })[];
        } | {
            kind: "SplitCoins";
            coin: {
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            };
            amounts: ({
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            })[];
        } | {
            kind: "MergeCoins";
            destination: {
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            };
            sources: ({
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            })[];
        } | {
            type: {
                Some: import("../bcs/index.js").TypeTag;
            } | {
                None: true | null;
            };
            kind: "MakeMoveVec";
            objects: ({
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            })[];
        } | {
            kind: "Publish";
            modules: number[][];
            dependencies: string[];
        } | {
            kind: "Upgrade";
            modules: number[][];
            dependencies: string[];
            packageId: string;
            ticket: {
                index: number;
                kind: "Input";
                type?: "object" | undefined;
                value?: any;
            } | {
                type: "pure";
                index: number;
                kind: "Input";
                value?: any;
            } | {
                kind: "GasCoin";
            } | {
                index: number;
                kind: "Result";
            } | {
                index: number;
                resultIndex: number;
                kind: "NestedResult";
            };
        })[];
        gasConfig: {
            owner?: string | undefined;
            payment?: {
                digest: string;
                objectId: string;
                version: string | number | bigint;
            }[] | undefined;
            price?: string | number | bigint | undefined;
            budget?: string | number | bigint | undefined;
        };
        sender?: string | undefined;
        expiration?: {
            Epoch: number;
        } | {
            None: true | null;
        } | null | undefined;
    };
    get [TRANSACTION_BRAND](): boolean;
    get pure(): ReturnType<typeof createPure>;
    constructor(transaction?: TransactionBlock);
    /** Returns an argument for the gas coin, to be used in a transaction. */
    get gas(): TransactionObjectArgument;
    /**
     * Add a new object input to the transaction.
     */
    object(value: TransactionObjectInput): TransactionObjectArgument;
    /**
     * Add a new object input to the transaction using the fully-resolved object reference.
     * If you only have an object ID, use `builder.object(id)` instead.
     */
    objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>): TransactionObjectArgument;
    /**
     * Add a new receiving input to the transaction using the fully-resolved object reference.
     * If you only have an object ID, use `builder.object(id)` instead.
     */
    receivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>): TransactionObjectArgument;
    /**
     * Add a new shared object input to the transaction using the fully-resolved shared object reference.
     * If you only have an object ID, use `builder.object(id)` instead.
     */
    sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>): TransactionObjectArgument;
    /** Add a transaction to the transaction block. */
    add(transaction: TransactionType): TransactionResult;
    splitCoins(coin: TransactionObjectArgument | string, amounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[]): TransactionResult;
    mergeCoins(destination: TransactionObjectArgument | string, sources: (TransactionObjectArgument | string)[]): TransactionResult;
    publish({ modules, dependencies }: {
        modules: number[][] | string[];
        dependencies: string[];
    }): TransactionResult;
    upgrade({ modules, dependencies, packageId, ticket, }: {
        modules: number[][] | string[];
        dependencies: string[];
        packageId: string;
        ticket: TransactionObjectArgument | string;
    }): TransactionResult;
    moveCall({ arguments: args, typeArguments, target, }: {
        arguments?: (TransactionArgument | SerializedBcs<any>)[];
        typeArguments?: string[];
        target: `${string}::${string}::${string}`;
    }): TransactionResult;
    transferObjects(objects: (TransactionObjectArgument | string)[], address: TransactionArgument | SerializedBcs<any> | string): TransactionResult;
    makeMoveVec({ type, objects, }: {
        objects: (TransactionObjectArgument | string)[];
        type?: string;
    }): TransactionResult;
    /**
     * Serialize the transaction to a string so that it can be sent to a separate context.
     * This is different from `build` in that it does not serialize to BCS bytes, and instead
     * uses a separate format that is unique to the transaction builder. This allows
     * us to serialize partially-complete transactions, that can then be completed and
     * built in a separate context.
     *
     * For example, a dapp can construct a transaction, but not provide gas objects
     * or a gas budget. The transaction then can be sent to the wallet, where this
     * information is automatically filled in (e.g. by querying for coin objects
     * and performing a dry run).
     */
    serialize(): string;
    /** Build the transaction to BCS bytes, and sign it with the provided keypair. */
    sign(options: SignOptions): Promise<SignatureWithBytes>;
    /** Build the transaction to BCS bytes. */
    build(options?: BuildOptions): Promise<Uint8Array>;
    /** Derive transaction digest */
    getDigest(options?: {
        client?: SuiClient;
    }): Promise<string>;
}
export {};
