{
  "version": 3,
  "sources": ["../../../src/builder/TransactionBlock.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SerializedBcs } from '@mysten/bcs';\nimport { fromB64, isSerializedBcs } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\n\nimport { bcs } from '../bcs/index.js';\nimport type { ProtocolConfig, SuiClient, SuiMoveNormalizedType } from '../client/index.js';\nimport type { Keypair, SignatureWithBytes } from '../cryptography/index.js';\nimport type { SuiObjectResponse } from '../types/index.js';\nimport {\n\textractMutableReference,\n\textractReference,\n\textractStructTag,\n\tgetObjectReference,\n\tSuiObjectRef,\n} from '../types/index.js';\nimport { SUI_TYPE_ARG } from '../utils/index.js';\nimport { normalizeSuiAddress, normalizeSuiObjectId } from '../utils/sui-types.js';\nimport type { ObjectCallArg } from './Inputs.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tPureCallArg,\n} from './Inputs.js';\nimport { createPure } from './pure.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { MoveCallTransaction, TransactionArgument, TransactionType } from './Transactions.js';\nimport { TransactionBlockInput, Transactions } from './Transactions.js';\nimport { create } from './utils.js';\n\nexport type TransactionObjectArgument = Exclude<\n\tTransactionArgument,\n\t{ kind: 'Input'; type: 'pure' }\n>;\n\nexport type TransactionResult = Extract<TransactionArgument, { kind: 'Result' }> &\n\tExtract<TransactionArgument, { kind: 'NestedResult' }>[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction isReceivingType(normalizedType: SuiMoveNormalizedType): boolean {\n\tconst tag = extractStructTag(normalizedType);\n\tif (tag) {\n\t\treturn (\n\t\t\ttag.Struct.address === '0x2' &&\n\t\t\ttag.Struct.module === 'transfer' &&\n\t\t\ttag.Struct.name === 'Receiving'\n\t\t);\n\t}\n\treturn false;\n}\n\nfunction expectClient(options: BuildOptions): SuiClient {\n\tif (!options.client) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.client;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tclient?: SuiClient;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\ninterface SignOptions extends BuildOptions {\n\tsigner: Keypair;\n}\n\nexport function isTransactionBlock(obj: unknown): obj is TransactionBlock {\n\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n}\n\nexport type TransactionObjectInput = string | ObjectCallArg | TransactionObjectArgument;\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\t// Temporary workaround for the wallet interface accidentally serializing transaction blocks via postMessage\n\tget pure(): ReturnType<typeof createPure> {\n\t\tObject.defineProperty(this, 'pure', {\n\t\t\tenumerable: false,\n\t\t\tvalue: createPure((value, type) => {\n\t\t\t\tif (isSerializedBcs(value)) {\n\t\t\t\t\treturn this.#input('pure', {\n\t\t\t\t\t\tPure: Array.from(value.toBytes()),\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// TODO: we can also do some deduplication here\n\t\t\t\treturn this.#input(\n\t\t\t\t\t'pure',\n\t\t\t\t\tvalue instanceof Uint8Array\n\t\t\t\t\t\t? Inputs.Pure(value)\n\t\t\t\t\t\t: type\n\t\t\t\t\t\t? Inputs.Pure(value, type)\n\t\t\t\t\t\t: value,\n\t\t\t\t);\n\t\t\t}),\n\t\t});\n\n\t\treturn this.pure;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionObjectArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input<T extends 'object' | 'pure'>(type: T, value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input as Extract<typeof input, { type: T }>;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: TransactionObjectInput) {\n\t\tif (typeof value === 'object' && 'kind' in value) {\n\t\t\treturn value;\n\t\t}\n\n\t\tconst id = getIdFromCallArg(value);\n\t\t// deduplicate\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t) as Extract<TransactionArgument, { type?: 'object' }> | undefined;\n\t\treturn (\n\t\t\tinserted ??\n\t\t\tthis.#input('object', typeof value === 'string' ? normalizeSuiAddress(value) : value)\n\t\t);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new receiving input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\treceivingRef(...args: Parameters<(typeof Inputs)['ReceivingRef']>) {\n\t\treturn this.object(Inputs.ReceivingRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t#normalizeTransactionArgument(\n\t\targ: TransactionArgument | SerializedBcs<any>,\n\t): TransactionArgument {\n\t\tif (isSerializedBcs(arg)) {\n\t\t\treturn this.pure(arg);\n\t\t}\n\n\t\treturn arg as TransactionArgument;\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(\n\t\tcoin: TransactionObjectArgument | string,\n\t\tamounts: (TransactionArgument | SerializedBcs<any> | number | string | bigint)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.SplitCoins(\n\t\t\t\ttypeof coin === 'string' ? this.object(coin) : coin,\n\t\t\t\tamounts.map((amount) =>\n\t\t\t\t\ttypeof amount === 'number' || typeof amount === 'bigint' || typeof amount === 'string'\n\t\t\t\t\t\t? this.pure.u64(amount)\n\t\t\t\t\t\t: this.#normalizeTransactionArgument(amount),\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\t}\n\tmergeCoins(\n\t\tdestination: TransactionObjectArgument | string,\n\t\tsources: (TransactionObjectArgument | string)[],\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.MergeCoins(\n\t\t\t\ttypeof destination === 'string' ? this.object(destination) : destination,\n\t\t\t\tsources.map((src) => (typeof src === 'string' ? this.object(src) : src)),\n\t\t\t),\n\t\t);\n\t}\n\tpublish({ modules, dependencies }: { modules: number[][] | string[]; dependencies: string[] }) {\n\t\treturn this.add(\n\t\t\tTransactions.Publish({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t}),\n\t\t);\n\t}\n\tupgrade({\n\t\tmodules,\n\t\tdependencies,\n\t\tpackageId,\n\t\tticket,\n\t}: {\n\t\tmodules: number[][] | string[];\n\t\tdependencies: string[];\n\t\tpackageId: string;\n\t\tticket: TransactionObjectArgument | string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.Upgrade({\n\t\t\t\tmodules,\n\t\t\t\tdependencies,\n\t\t\t\tpackageId,\n\t\t\t\tticket: typeof ticket === 'string' ? this.object(ticket) : ticket,\n\t\t\t}),\n\t\t);\n\t}\n\tmoveCall({\n\t\targuments: args,\n\t\ttypeArguments,\n\t\ttarget,\n\t}: {\n\t\targuments?: (TransactionArgument | SerializedBcs<any>)[];\n\t\ttypeArguments?: string[];\n\t\ttarget: `${string}::${string}::${string}`;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MoveCall({\n\t\t\t\targuments: args?.map((arg) => this.#normalizeTransactionArgument(arg)),\n\t\t\t\ttypeArguments,\n\t\t\t\ttarget,\n\t\t\t}),\n\t\t);\n\t}\n\ttransferObjects(\n\t\tobjects: (TransactionObjectArgument | string)[],\n\t\taddress: TransactionArgument | SerializedBcs<any> | string,\n\t) {\n\t\treturn this.add(\n\t\t\tTransactions.TransferObjects(\n\t\t\t\tobjects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t\ttypeof address === 'string'\n\t\t\t\t\t? this.pure.address(address)\n\t\t\t\t\t: this.#normalizeTransactionArgument(address),\n\t\t\t),\n\t\t);\n\t}\n\tmakeMoveVec({\n\t\ttype,\n\t\tobjects,\n\t}: {\n\t\tobjects: (TransactionObjectArgument | string)[];\n\t\ttype?: string;\n\t}) {\n\t\treturn this.add(\n\t\t\tTransactions.MakeMoveVec({\n\t\t\t\ttype,\n\t\t\t\tobjects: objects.map((obj) => (typeof obj === 'string' ? this.object(obj) : obj)),\n\t\t\t}),\n\t\t);\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes, and sign it with the provided keypair. */\n\tasync sign(options: SignOptions): Promise<SignatureWithBytes> {\n\t\tconst { signer, ...buildOptions } = options;\n\t\tconst bytes = await this.build(buildOptions);\n\t\treturn signer.signTransactionBlock(bytes);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest(\n\t\toptions: {\n\t\t\tclient?: SuiClient;\n\t\t} = {},\n\t): Promise<string> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectClient(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectClient(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\tinputs.forEach((input) => {\n\t\t\tif (input.type === 'object' && typeof input.value === 'string') {\n\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\tobjectsToResolve.push({ id: normalizeSuiAddress(input.value), input });\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Special handling for values that where previously encoded using the wellKnownEncoding pattern.\n\t\t\t// This should only happen when transaction block data was hydrated from an old version of the SDK\n\t\t\tif (transaction.kind === 'SplitCoins') {\n\t\t\t\ttransaction.amounts.forEach((amount) => {\n\t\t\t\t\tif (amount.kind === 'Input') {\n\t\t\t\t\t\tconst input = inputs[amount.index];\n\t\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.U64.serialize(input.value));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (transaction.kind === 'TransferObjects') {\n\t\t\t\tif (transaction.address.kind === 'Input') {\n\t\t\t\t\tconst input = inputs[transaction.address.index];\n\t\t\t\t\tif (typeof input.value !== 'object') {\n\t\t\t\t\t\tinput.value = Inputs.Pure(bcs.Address.serialize(input.value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectClient(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectClient(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(`The following input objects are invalid: ${invalidObjects.join(', ')}`);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst owner = object.data?.owner;\n\t\t\t\tconst initialSharedVersion =\n\t\t\t\t\towner && typeof owner === 'object' && 'Shared' in owner\n\t\t\t\t\t\t? owner.Shared.initial_shared_version\n\t\t\t\t\t\t: undefined;\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference or taken by value, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst isByValue =\n\t\t\t\t\t\tnormalizedType != null &&\n\t\t\t\t\t\textractMutableReference(normalizedType) == null &&\n\t\t\t\t\t\textractReference(normalizedType) == null;\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\tisByValue ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else if (normalizedType && isReceivingType(normalizedType)) {\n\t\t\t\t\tinput.value = Inputs.ReceivingRef(getObjectReference(object)!);\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(getObjectReference(object as SuiObjectResponse)!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.client) {\n\t\t\toptions.protocolConfig = await options.client.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectClient(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["import_bcs", "import_utils", "chunk"]
}
