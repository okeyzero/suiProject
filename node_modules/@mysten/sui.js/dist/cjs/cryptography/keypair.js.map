{
  "version": 3,
  "sources": ["../../../src/cryptography/keypair.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nimport { bcs } from '../bcs/index.js';\nimport { IntentScope, messageWithIntent } from './intent.js';\nimport type { PublicKey } from './publickey.js';\nimport type { SignatureScheme } from './signature-scheme.js';\nimport type { SerializedSignature } from './signature.js';\nimport { toSerializedSignature } from './signature.js';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\n\nexport type ExportedKeypair = {\n\tschema: SignatureScheme;\n\tprivateKey: string;\n};\n\nexport interface SignatureWithBytes {\n\tbytes: string;\n\tsignature: SerializedSignature;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class BaseSigner {\n\tabstract sign(bytes: Uint8Array): Promise<Uint8Array>;\n\t/**\n\t * Sign messages with a specific intent. By combining the message bytes with the intent before hashing and signing,\n\t * it ensures that a signed message is tied to a specific purpose and domain separator is provided\n\t */\n\tasync signWithIntent(bytes: Uint8Array, intent: IntentScope): Promise<SignatureWithBytes> {\n\t\tconst intentMessage = messageWithIntent(intent, bytes);\n\t\tconst digest = blake2b(intentMessage, { dkLen: 32 });\n\n\t\tconst signature = toSerializedSignature({\n\t\t\tsignature: await this.sign(digest),\n\t\t\tsignatureScheme: this.getKeyScheme(),\n\t\t\tpublicKey: this.getPublicKey(),\n\t\t});\n\n\t\treturn {\n\t\t\tsignature,\n\t\t\tbytes: toB64(bytes),\n\t\t};\n\t}\n\t/**\n\t * Signs provided transaction block by calling `signWithIntent()` with a `TransactionData` provided as intent scope\n\t */\n\tasync signTransactionBlock(bytes: Uint8Array) {\n\t\treturn this.signWithIntent(bytes, IntentScope.TransactionData);\n\t}\n\t/**\n\t * Signs provided personal message by calling `signWithIntent()` with a `PersonalMessage` provided as intent scope\n\t */\n\tasync signPersonalMessage(bytes: Uint8Array) {\n\t\treturn this.signWithIntent(\n\t\t\tbcs.vector(bcs.u8()).serialize(bytes).toBytes(),\n\t\t\tIntentScope.PersonalMessage,\n\t\t);\n\t}\n\n\ttoSuiAddress(): string {\n\t\treturn this.getPublicKey().toSuiAddress();\n\t}\n\n\t/**\n\t * Return the signature for the data.\n\t * Prefer the async version {@link sign}, as this method will be deprecated in a future release.\n\t */\n\tabstract signData(data: Uint8Array): Uint8Array;\n\n\t/**\n\t * Get the key scheme of the keypair: Secp256k1 or ED25519\n\t */\n\tabstract getKeyScheme(): SignatureScheme;\n\n\t/**\n\t * The public key for this keypair\n\t */\n\tabstract getPublicKey(): PublicKey;\n}\n\n/**\n * TODO: Document\n */\nexport abstract class Keypair extends BaseSigner {\n\tabstract export(): ExportedKeypair;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA,iBAAsB;AACtB,qBAAwB;AAExB,IAAAA,cAAoB;AACpB,oBAA+C;AAI/C,uBAAsC;AAE/B,MAAM,mBAAmB;AACzB,MAAM,0BAA0B;AAehC,MAAe,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhC,MAAM,eAAe,OAAmB,QAAkD;AACzF,UAAM,oBAAgB,iCAAkB,QAAQ,KAAK;AACrD,UAAM,aAAS,wBAAQ,eAAe,EAAE,OAAO,GAAG,CAAC;AAEnD,UAAM,gBAAY,wCAAsB;AAAA,MACvC,WAAW,MAAM,KAAK,KAAK,MAAM;AAAA,MACjC,iBAAiB,KAAK,aAAa;AAAA,MACnC,WAAW,KAAK,aAAa;AAAA,IAC9B,CAAC;AAED,WAAO;AAAA,MACN;AAAA,MACA,WAAO,kBAAM,KAAK;AAAA,IACnB;AAAA,EACD;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,qBAAqB,OAAmB;AAC7C,WAAO,KAAK,eAAe,OAAO,0BAAY,eAAe;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB,OAAmB;AAC5C,WAAO,KAAK;AAAA,MACX,gBAAI,OAAO,gBAAI,GAAG,CAAC,EAAE,UAAU,KAAK,EAAE,QAAQ;AAAA,MAC9C,0BAAY;AAAA,IACb;AAAA,EACD;AAAA,EAEA,eAAuB;AACtB,WAAO,KAAK,aAAa,EAAE,aAAa;AAAA,EACzC;AAiBD;AAKO,MAAe,gBAAgB,WAAW;AAEjD;",
  "names": ["import_bcs"]
}
