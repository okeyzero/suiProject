{
  "version": 3,
  "sources": ["../../../src/bcs/index.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n\tbcs,\n\tBCS as BcsRegistry,\n\tfromB58,\n\tfromHEX,\n\tgetSuiMoveConfig,\n\ttoB58,\n\ttoHEX,\n} from '@mysten/bcs';\nimport type { BcsType, BcsTypeOptions } from '@mysten/bcs';\n\nimport type { MoveCallTransaction } from '../builder/Transactions.js';\nimport type { SuiObjectRef as SuiObjectRefType } from '../types/objects.js';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../utils/sui-types.js';\nimport { TypeTagSerializer } from './type-tag-serializer.js';\n\nexport { TypeTagSerializer } from './type-tag-serializer.js';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n\t/** Hex code as string representing the object id */\n\tobjectId: string;\n\n\t/** The version the object was shared at */\n\tinitialSharedVersion: number | string;\n\n\t/** Whether reference is mutable */\n\tmutable: boolean;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n\t| { ImmOrOwned: SuiObjectRefType }\n\t| { Shared: SharedObjectRef }\n\t| { Receiving: SuiObjectRefType };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n\treturn (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n\t| { bool: null | true }\n\t| { u8: null | true }\n\t| { u64: null | true }\n\t| { u128: null | true }\n\t| { address: null | true }\n\t| { signer: null | true }\n\t| { vector: TypeTag }\n\t| { struct: StructTag }\n\t| { u16: null | true }\n\t| { u32: null | true }\n\t| { u256: null | true };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n\tpayment: SuiObjectRefType[];\n\towner: string; // Gas Object's owner\n\tprice: number;\n\tbudget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\nconst bcsRegistry = new BcsRegistry({\n\t...getSuiMoveConfig(),\n\ttypes: {\n\t\tenums: {\n\t\t\t'Option<T>': {\n\t\t\t\tNone: null,\n\t\t\t\tSome: 'T',\n\t\t\t},\n\t\t},\n\t},\n});\n\nfunction unsafe_u64(options?: BcsTypeOptions<number>) {\n\treturn bcs\n\t\t.u64({\n\t\t\tname: 'unsafe_u64',\n\t\t\t...(options as object),\n\t\t})\n\t\t.transform({\n\t\t\tinput: (val: number) => val,\n\t\t\toutput: (val) => Number(val),\n\t\t});\n}\n\nfunction optionEnum<T extends BcsType<any, any>>(type: T) {\n\treturn bcs.enum('Option', {\n\t\tNone: null,\n\t\tSome: type,\n\t});\n}\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nfunction enumKind<T extends object, Input extends object>(type: BcsType<T, Input>) {\n\ttype Merge<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\ttype EnumKindTransform<T> = T extends infer U\n\t\t? Merge<(U[keyof U] extends null | boolean ? object : U[keyof U]) & { kind: keyof U }>\n\t\t: never;\n\n\treturn type.transform({\n\t\tinput: (val: EnumKindTransform<Input>) =>\n\t\t\t({\n\t\t\t\t[val.kind]: val,\n\t\t\t}) as Input,\n\t\toutput: (val) => {\n\t\t\tconst key = Object.keys(val)[0] as keyof T;\n\n\t\t\treturn { kind: key, ...val[key] } as EnumKindTransform<T>;\n\t\t},\n\t});\n}\n\nconst Address = bcs.bytes(SUI_ADDRESS_LENGTH).transform({\n\tinput: (val: string | Uint8Array) =>\n\t\ttypeof val === 'string' ? fromHEX(normalizeSuiAddress(val)) : val,\n\toutput: (val) => normalizeSuiAddress(toHEX(val)),\n});\n\nconst ObjectDigest = bcs.vector(bcs.u8()).transform({\n\tname: 'ObjectDigest',\n\tinput: (value: string) => fromB58(value),\n\toutput: (value) => toB58(new Uint8Array(value)),\n});\n\nconst SuiObjectRef = bcs.struct('SuiObjectRef', {\n\tobjectId: Address,\n\tversion: bcs.u64(),\n\tdigest: ObjectDigest,\n});\n\nconst SharedObjectRef = bcs.struct('SharedObjectRef', {\n\tobjectId: Address,\n\tinitialSharedVersion: bcs.u64(),\n\tmutable: bcs.bool(),\n});\n\nconst ObjectArg = bcs.enum('ObjectArg', {\n\tImmOrOwned: SuiObjectRef,\n\tShared: SharedObjectRef,\n\tReceiving: SuiObjectRef,\n});\n\nconst CallArg = bcs.enum('CallArg', {\n\tPure: bcs.vector(bcs.u8()),\n\tObject: ObjectArg,\n\tObjVec: bcs.vector(ObjectArg),\n});\n\nconst TypeTag: BcsType<TypeTag> = bcs.enum('TypeTag', {\n\tbool: null,\n\tu8: null,\n\tu64: null,\n\tu128: null,\n\taddress: null,\n\tsigner: null,\n\tvector: bcs.lazy(() => TypeTag),\n\tstruct: bcs.lazy(() => StructTag),\n\tu16: null,\n\tu32: null,\n\tu256: null,\n}) as never;\n\nconst Argument = enumKind(\n\tbcs.enum('Argument', {\n\t\tGasCoin: null,\n\t\tInput: bcs.struct('Input', { index: bcs.u16() }),\n\t\tResult: bcs.struct('Result', { index: bcs.u16() }),\n\t\tNestedResult: bcs.struct('NestedResult', { index: bcs.u16(), resultIndex: bcs.u16() }),\n\t}),\n);\n\n/** Custom serializer for decoding package, module, function easier */\nconst ProgrammableMoveCall = bcs\n\t.struct('ProgrammableMoveCall', {\n\t\tpackage: Address,\n\t\tmodule: bcs.string(),\n\t\tfunction: bcs.string(),\n\t\ttype_arguments: bcs.vector(TypeTag),\n\t\targuments: bcs.vector(Argument),\n\t})\n\t.transform({\n\t\tinput: (data: MoveCallTransaction) => {\n\t\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t\t);\n\n\t\t\treturn {\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t};\n\t\t},\n\t\toutput: (data) => {\n\t\t\treturn {\n\t\t\t\ttarget: [data.package, data.module, data.function].join(\n\t\t\t\t\t'::',\n\t\t\t\t) as `${string}::${string}::${string}`,\n\t\t\t\targuments: data.arguments,\n\t\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t\t};\n\t\t},\n\t});\n\nconst Transaction = enumKind(\n\tbcs.enum('Transaction', {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: ProgrammableMoveCall,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: bcs.struct('TransferObjects', {\n\t\t\tobjects: bcs.vector(Argument),\n\t\t\taddress: Argument,\n\t\t}),\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: bcs.struct('SplitCoins', { coin: Argument, amounts: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: bcs.struct('MergeCoins', { destination: Argument, sources: bcs.vector(Argument) }),\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: bcs.struct('Publish', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t}),\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: bcs.struct('MakeMoveVec', {\n\t\t\ttype: optionEnum(TypeTag),\n\t\t\tobjects: bcs.vector(Argument),\n\t\t}),\n\t\t/**  */\n\t\tUpgrade: bcs.struct('Upgrade', {\n\t\t\tmodules: bcs.vector(bcs.vector(bcs.u8())),\n\t\t\tdependencies: bcs.vector(Address),\n\t\t\tpackageId: Address,\n\t\t\tticket: Argument,\n\t\t}),\n\t}),\n);\n\nconst ProgrammableTransaction = bcs.struct('ProgrammableTransaction', {\n\tinputs: bcs.vector(CallArg),\n\ttransactions: bcs.vector(Transaction),\n});\n\nconst TransactionKind = bcs.enum('TransactionKind', {\n\tProgrammableTransaction: ProgrammableTransaction,\n\tChangeEpoch: null,\n\tGenesis: null,\n\tConsensusCommitPrologue: null,\n});\n\nconst TransactionExpiration = bcs.enum('TransactionExpiration', {\n\tNone: null,\n\tEpoch: unsafe_u64(),\n});\n\nconst StructTag = bcs.struct('StructTag', {\n\taddress: Address,\n\tmodule: bcs.string(),\n\tname: bcs.string(),\n\ttypeParams: bcs.vector(TypeTag),\n});\n\nconst GasData = bcs.struct('GasData', {\n\tpayment: bcs.vector(SuiObjectRef),\n\towner: Address,\n\tprice: bcs.u64(),\n\tbudget: bcs.u64(),\n});\n\nconst TransactionDataV1 = bcs.struct('TransactionDataV1', {\n\tkind: TransactionKind,\n\tsender: Address,\n\tgasData: GasData,\n\texpiration: TransactionExpiration,\n});\n\nconst TransactionData = bcs.enum('TransactionData', {\n\tV1: TransactionDataV1,\n});\n\n// Signed transaction data needed to generate transaction digest.\nconst SenderSignedData = bcs.struct('SenderSignedData', {\n\tdata: TransactionData,\n\ttxSignatures: bcs.vector(bcs.vector(bcs.u8())),\n});\n\nconst CompressedSignature = bcs.enum('CompressedSignature', {\n\tED25519: bcs.fixedArray(64, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(64, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(64, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst PublicKey = bcs.enum('PublicKey', {\n\tED25519: bcs.fixedArray(32, bcs.u8()),\n\tSecp256k1: bcs.fixedArray(33, bcs.u8()),\n\tSecp256r1: bcs.fixedArray(33, bcs.u8()),\n\tZkLogin: bcs.vector(bcs.u8()),\n});\n\nconst MultiSigPkMap = bcs.struct('MultiSigPkMap', {\n\tpubKey: PublicKey,\n\tweight: bcs.u8(),\n});\n\nconst MultiSigPublicKey = bcs.struct('MultiSigPublicKey', {\n\tpk_map: bcs.vector(MultiSigPkMap),\n\tthreshold: bcs.u16(),\n});\n\nconst MultiSig = bcs.struct('MultiSig', {\n\tsigs: bcs.vector(CompressedSignature),\n\tbitmap: bcs.u16(),\n\tmultisig_pk: MultiSigPublicKey,\n});\n\nconst suiBcs = {\n\t...bcs,\n\tU8: bcs.u8(),\n\tU16: bcs.u16(),\n\tU32: bcs.u32(),\n\tU64: bcs.u64(),\n\tU128: bcs.u128(),\n\tU256: bcs.u256(),\n\tULEB128: bcs.uleb128(),\n\tBool: bcs.bool(),\n\tString: bcs.string(),\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n\n\t// preserve backwards compatibility with old bcs export\n\tser: bcsRegistry.ser.bind(bcsRegistry),\n\tde: bcsRegistry.de.bind(bcsRegistry),\n\tgetTypeInterface: bcsRegistry.getTypeInterface.bind(bcsRegistry),\n\thasType: bcsRegistry.hasType.bind(bcsRegistry),\n\tparseTypeName: bcsRegistry.parseTypeName.bind(bcsRegistry),\n\tregisterAddressType: bcsRegistry.registerAddressType.bind(bcsRegistry),\n\tregisterAlias: bcsRegistry.registerAlias.bind(bcsRegistry),\n\tregisterBcsType: bcsRegistry.registerBcsType.bind(bcsRegistry),\n\tregisterEnumType: bcsRegistry.registerEnumType.bind(bcsRegistry),\n\tregisterStructType: bcsRegistry.registerStructType.bind(bcsRegistry),\n\tregisterType: bcsRegistry.registerType.bind(bcsRegistry),\n\ttypes: bcsRegistry.types,\n};\n\nbcsRegistry.registerBcsType('utf8string', () => bcs.string({ name: 'utf8string' }));\nbcsRegistry.registerBcsType('unsafe_u64', () => unsafe_u64());\nbcsRegistry.registerBcsType('enumKind', (T) => enumKind(T));\n\n[\n\tAddress,\n\tArgument,\n\tCallArg,\n\tCompressedSignature,\n\tGasData,\n\tMultiSig,\n\tMultiSigPkMap,\n\tMultiSigPublicKey,\n\tObjectArg,\n\tObjectDigest,\n\tProgrammableMoveCall,\n\tProgrammableTransaction,\n\tPublicKey,\n\tSenderSignedData,\n\tSharedObjectRef,\n\tStructTag,\n\tSuiObjectRef,\n\tTransaction,\n\tTransactionData,\n\tTransactionDataV1,\n\tTransactionExpiration,\n\tTransactionKind,\n\tTypeTag,\n].forEach((type) => {\n\tbcsRegistry.registerBcsType(type.name, () => type);\n});\n\nexport { suiBcs as bcs, bcsRegistry };\n"],
  "mappings": "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",
  "names": ["TypeTagSerializer"]
}
