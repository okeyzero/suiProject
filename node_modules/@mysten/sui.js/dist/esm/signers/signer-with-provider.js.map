{
  "version": 3,
  "sources": ["../../../src/signers/signer-with-provider.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\n\nimport { bcs } from '../bcs/index.js';\nimport type { TransactionBlock } from '../builder/TransactionBlock.js';\nimport { isTransactionBlock } from '../builder/TransactionBlock.js';\nimport { TransactionBlockDataBuilder } from '../builder/TransactionBlockData.js';\nimport type {\n\tDevInspectResults,\n\tDryRunTransactionBlockResponse,\n\tExecuteTransactionRequestType,\n\tSuiClient,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../client/index.js';\nimport { IntentScope, messageWithIntent } from '../cryptography/intent.js';\nimport type { SerializedSignature } from '../cryptography/signature.js';\nimport type { Signer } from './signer.js';\nimport type { SignedMessage, SignedTransaction } from './types.js';\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class SignerWithProvider implements Signer {\n\treadonly client: SuiClient;\n\n\t///////////////////\n\t// Sub-classes MUST implement these\n\n\t// Returns the checksum address\n\tabstract getAddress(): Promise<string>;\n\n\t/**\n\t * Returns the signature for the data and the public key of the signer\n\t */\n\tabstract signData(data: Uint8Array): Promise<SerializedSignature>;\n\n\t// Returns a new instance of the Signer, connected to provider.\n\t// This MAY throw if changing providers is not supported.\n\tabstract connect(client: SuiClient): SignerWithProvider;\n\n\t///////////////////\n\t// Sub-classes MAY override these\n\n\tconstructor(client: SuiClient) {\n\t\tthis.client = client as SuiClient;\n\t}\n\n\t/**\n\t * Sign a message using the keypair, with the `PersonalMessage` intent.\n\t */\n\tasync signMessage(input: { message: Uint8Array }): Promise<SignedMessage> {\n\t\tconst signature = await this.signData(\n\t\t\tmessageWithIntent(\n\t\t\t\tIntentScope.PersonalMessage,\n\t\t\t\tbcs.vector(bcs.u8()).serialize(input.message).toBytes(),\n\t\t\t),\n\t\t);\n\n\t\treturn {\n\t\t\tmessageBytes: toB64(input.message),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\tprotected async prepareTransactionBlock(transactionBlock: Uint8Array | TransactionBlock) {\n\t\tif (isTransactionBlock(transactionBlock)) {\n\t\t\t// If the sender has not yet been set on the transaction, then set it.\n\t\t\t// NOTE: This allows for signing transactions with mis-matched senders, which is important for sponsored transactions.\n\t\t\ttransactionBlock.setSenderIfNotSet(await this.getAddress());\n\t\t\treturn await transactionBlock.build({\n\t\t\t\tclient: this.client,\n\t\t\t});\n\t\t}\n\t\tif (transactionBlock instanceof Uint8Array) {\n\t\t\treturn transactionBlock;\n\t\t}\n\t\tthrow new Error('Unknown transaction format');\n\t}\n\n\t/**\n\t * Sign a transaction.\n\t */\n\tasync signTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | TransactionBlock;\n\t}): Promise<SignedTransaction> {\n\t\tconst transactionBlockBytes = await this.prepareTransactionBlock(input.transactionBlock);\n\n\t\tconst intentMessage = messageWithIntent(IntentScope.TransactionData, transactionBlockBytes);\n\t\tconst signature = await this.signData(intentMessage);\n\n\t\treturn {\n\t\t\ttransactionBlockBytes: toB64(transactionBlockBytes),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\t/**\n\t * Sign a transaction block and submit to the Fullnode for execution.\n\t *\n\t * @param options specify which fields to return (e.g., transaction, effects, events, etc).\n\t * By default, only the transaction digest will be returned.\n\t * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.\n\t * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n\t */\n\tasync signAndExecuteTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | TransactionBlock;\n\t\t/** specify which fields to return (e.g., transaction, effects, events, etc). By default, only the transaction digest will be returned. */\n\t\toptions?: SuiTransactionBlockResponseOptions;\n\t\t/** `WaitForEffectsCert` or `WaitForLocalExecution`, see details in `ExecuteTransactionRequestType`.\n\t\t * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n\t\t */\n\t\trequestType?: ExecuteTransactionRequestType;\n\t}): Promise<SuiTransactionBlockResponse> {\n\t\tconst { transactionBlockBytes, signature } = await this.signTransactionBlock({\n\t\t\ttransactionBlock: input.transactionBlock,\n\t\t});\n\n\t\treturn await this.client.executeTransactionBlock({\n\t\t\ttransactionBlock: transactionBlockBytes,\n\t\t\tsignature,\n\t\t\toptions: input.options,\n\t\t\trequestType: input.requestType,\n\t\t});\n\t}\n\n\t/**\n\t * Derive transaction digest from\n\t * @param tx BCS serialized transaction data or a `Transaction` object\n\t * @returns transaction digest\n\t */\n\tasync getTransactionBlockDigest(tx: Uint8Array | TransactionBlock): Promise<string> {\n\t\tif (isTransactionBlock(tx)) {\n\t\t\ttx.setSenderIfNotSet(await this.getAddress());\n\t\t\treturn tx.getDigest({ client: this.client });\n\t\t} else if (tx instanceof Uint8Array) {\n\t\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(tx);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction format.');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the transaction in dev-inpsect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(\n\t\tinput: Omit<Parameters<SuiClient['devInspectTransactionBlock']>[0], 'sender'>,\n\t): Promise<DevInspectResults> {\n\t\tconst address = await this.getAddress();\n\t\treturn this.client.devInspectTransactionBlock({\n\t\t\tsender: address,\n\t\t\t...input,\n\t\t});\n\t}\n\n\t/**\n\t * Dry run a transaction and return the result.\n\t */\n\tasync dryRunTransactionBlock(input: {\n\t\ttransactionBlock: TransactionBlock | string | Uint8Array;\n\t}): Promise<DryRunTransactionBlockResponse> {\n\t\tlet dryRunTxBytes: Uint8Array;\n\t\tif (isTransactionBlock(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(await this.getAddress());\n\t\t\tdryRunTxBytes = await input.transactionBlock.build({\n\t\t\t\tclient: this.client,\n\t\t\t});\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdryRunTxBytes = fromB64(input.transactionBlock);\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdryRunTxBytes = input.transactionBlock;\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction format');\n\t\t}\n\n\t\treturn this.client.dryRunTransactionBlock({\n\t\t\ttransactionBlock: dryRunTxBytes,\n\t\t});\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
